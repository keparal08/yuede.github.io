---
layout: default
section: open_source 
title: "Yuede Ji: Open Resource"
---
&nbsp;

#### If you have any questions, feel free to contact me. 

## 1. Reducing Attack Surfaces with Vulnerability Detection 

Software vendors usually do not share source code for obvious reasons, hence to find the vulnerabilities, one needs to analyze the binary code, which is challenging because the compilers and run-time dependencies have introduced significant complexities. An effective binary code vulnerability detection method is code similarity detection, which is based on the fact that two pieces of code sharing the same vulnerability are similar. Existing approaches face two hurdles in their efforts to achieve high accuracy and coverage: (1) the challenge of comparing binary code with different compilation provenance (e.g., architecture, compiler family, compiler version, and optimization level); and (2) the existence of different degrees of code similarity.
To address these challenges, I built BugGraph (ASIACCS’21 [1]), a system that performs source-binary code similarity detection in two steps. First, BugGraph identifies the compilation provenance of the unknown binary code and compares it to known binaries with the same provenance. This avoids the comparison between binary code with different compilation provenance. Second, BugGraph utilizes a new graph triplet-loss network on the attributed control flow graph to generate accurate similarity scores. The experiments on four real-world datasets show that BugGraph achieves 90% and 75% true positive rate for syntax equivalent and similar code, respectively, an improvement of 16% and 24% over state-of-the-art methods. In addition, I applied BugGraph to investigate six commercial firmware of IoT devices and identified 140 vulnerabilities.
Knowing the compilation provenance of binary code is very helpful for further investigation, which has been used in malware analysis, code vulnerability detection, and code authorship identification. As existing tools for binary provenance identification show low coverage and accuracy, I built Vestige [2], a tool that can accurately identify the compilation provenance of a binary code. When applied to binary code vulnerability detection, Vestige can help to improve the top-1 hit rate of three recent code vulnerability detection methods by up to 27%.
In addition, I have studied the vulnerabilities caused by not well protected Android system services. I have built a system, scanned over 200 Android firmware, and found various new vulnerabilities [paper in-preparation].

## 2. Combating Evolving Cyber Threats with Graph-based Machine Learning

An advanced persistent threat (APT) is a stealthy threat actor by gaining unauthorized access to a network and hiding for a long period. To detect APT, my collaborators and I focused on a key stage, i.e., lateral movement, that happens when an attacker authenticates to new resources and traverses through the network. We design an unsupervised graph learning-based technique to detect lateral movement inside enterprise-level computer networks (RAID’20 [3]). The approach consists of two core components: an authentication graph, and an unsupervised graph-based machine learning pipeline which learns latent representations of the authenticating entities, and subsequently performs anomaly detection. We are able to detect malicious authentication events associated with lateral movement with a true positive rate of 85% and false positive rate of 0.9%, compared to 72% and 4.4% of traditional rule-based heuristics and non-graph anomaly detection algorithms.
Graph neural networks (GNNs) have achieved notable success for various applications. Typically, a GNN takes an attributed graph as input, in which each node is represented as a predefined feature vector. However, such a graph may not be able to capture critical information in many applications. For example, to detect the lateral movement, we build an authentication graph between hosts, while the critical activities inside the hosts are not captured, such as process communication graph and data provenance graph. Observing such a nested graph structure is a more accurate representation, I designed NestedGNN [4], the first neural network for nested graphs. We build NestedGNN on top of four traditional GNNs, i.e., GCN, GAT, GraphSAGE, and SGC. We evaluate NestedGNN with two real-world case studies on compromised host detection and protein functionality identification. NestedGNN is able to significantly improve the performance over traditional GNN models.
Besides, I am closely collaborating on a project to interpret graph-based machine learning techniques. To protect the social network, we designed an efficient method to detect malicious URLs [5], that won the best paper award at NPC 2014. To combat botnet, I conducted an empirical study on social botnet [6], designed BotCatch to detect botnet binaries with a hybrid of static and dynamic analysis [7], and designed DeepArmour to secure malware detection systems against adversarial attacks [8].

## 3. Scalable Computation for Graph-Centric Algorithms and Techniques

As shown previously, graph is an important representation used in security techniques, such as control and data flow graph in code analysis, friendship graph in the social network, and authentication graph in APT campaigns. To reduce the response time of corresponding security techniques, I design scalable graph analytics techniques to both speed up the computation and scale up the accommodated graph size.
Firstly, I designed iSpan (SC’18 [9]) to fast compute strongly connected components (SCCs) on both shared and distributed memory systems. We observe that SCC only requires the knowledge of connectivity among the vertices, while existing approaches directly use depth- or breadth-first search (DFS and BFS), which require strict synchronizations. Motivated by that, we advocate a new paradigm of identifying SCCs with simple spanning trees. The center of iSpan is a newly designed relaxed synchronization technique to fast construct spanning trees that are able to answer connectivity queries. The evaluations show that iSpan is able to significantly outperform current state-of-the-art DFS and BFS-based methods by average 18× and 4×, respectively. Further, iSpan can scale up to large graphs with up to one billion vertices and ten billion edges.
Secondly, I designed an adaptive system, named Aquila (HPDC’20 [10]), to fast compute a number of graph connectivity algorithms to fill the gap that the important connectivity algorithms are barely supported in existing parallel systems. Given a graph, Aquila first transforms the query if it can be answered with partial computation. During the computation, Aquila is able to greatly reduce the workload by up to 98%. Furthermore, Aquila identifies the irregular tasks in the connectivity algorithms and applies different parallel strategies for different tasks. As a result, Aquila significantly outperforms existing systems such as Multistep, Galois, Ligra, GraphChi, X-Stream, DFS, and Boost by 13×, 53×, 264×, 364×, 1,369×, 45×, and 255×, respectively. Besides, I have built SwarmGraph to compute million scale small graphs with multiple GPUs [11], an important project for security stand-point where we need to store and analyze many small graphs together.

{% include statistics.html %}
